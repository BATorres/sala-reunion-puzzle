// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  diagrama: (where?: DiagramaWhereInput) => Promise<boolean>;
  diagramaUsuario: (where?: DiagramaUsuarioWhereInput) => Promise<boolean>;
  sala: (where?: SalaWhereInput) => Promise<boolean>;
  usuario: (where?: UsuarioWhereInput) => Promise<boolean>;
  usuarioSala: (where?: UsuarioSalaWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  diagrama: (where: DiagramaWhereUniqueInput) => DiagramaNullablePromise;
  diagramas: (args?: {
    where?: DiagramaWhereInput;
    orderBy?: DiagramaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Diagrama>;
  diagramasConnection: (args?: {
    where?: DiagramaWhereInput;
    orderBy?: DiagramaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DiagramaConnectionPromise;
  diagramaUsuario: (
    where: DiagramaUsuarioWhereUniqueInput
  ) => DiagramaUsuarioNullablePromise;
  diagramaUsuarios: (args?: {
    where?: DiagramaUsuarioWhereInput;
    orderBy?: DiagramaUsuarioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DiagramaUsuario>;
  diagramaUsuariosConnection: (args?: {
    where?: DiagramaUsuarioWhereInput;
    orderBy?: DiagramaUsuarioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DiagramaUsuarioConnectionPromise;
  sala: (where: SalaWhereUniqueInput) => SalaNullablePromise;
  salas: (args?: {
    where?: SalaWhereInput;
    orderBy?: SalaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Sala>;
  salasConnection: (args?: {
    where?: SalaWhereInput;
    orderBy?: SalaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SalaConnectionPromise;
  usuario: (where: UsuarioWhereUniqueInput) => UsuarioNullablePromise;
  usuarios: (args?: {
    where?: UsuarioWhereInput;
    orderBy?: UsuarioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Usuario>;
  usuariosConnection: (args?: {
    where?: UsuarioWhereInput;
    orderBy?: UsuarioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UsuarioConnectionPromise;
  usuarioSala: (
    where: UsuarioSalaWhereUniqueInput
  ) => UsuarioSalaNullablePromise;
  usuarioSalas: (args?: {
    where?: UsuarioSalaWhereInput;
    orderBy?: UsuarioSalaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UsuarioSala>;
  usuarioSalasConnection: (args?: {
    where?: UsuarioSalaWhereInput;
    orderBy?: UsuarioSalaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UsuarioSalaConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDiagrama: (data: DiagramaCreateInput) => DiagramaPromise;
  updateDiagrama: (args: {
    data: DiagramaUpdateInput;
    where: DiagramaWhereUniqueInput;
  }) => DiagramaPromise;
  updateManyDiagramas: (args: {
    data: DiagramaUpdateManyMutationInput;
    where?: DiagramaWhereInput;
  }) => BatchPayloadPromise;
  upsertDiagrama: (args: {
    where: DiagramaWhereUniqueInput;
    create: DiagramaCreateInput;
    update: DiagramaUpdateInput;
  }) => DiagramaPromise;
  deleteDiagrama: (where: DiagramaWhereUniqueInput) => DiagramaPromise;
  deleteManyDiagramas: (where?: DiagramaWhereInput) => BatchPayloadPromise;
  createDiagramaUsuario: (
    data: DiagramaUsuarioCreateInput
  ) => DiagramaUsuarioPromise;
  updateDiagramaUsuario: (args: {
    data: DiagramaUsuarioUpdateInput;
    where: DiagramaUsuarioWhereUniqueInput;
  }) => DiagramaUsuarioPromise;
  upsertDiagramaUsuario: (args: {
    where: DiagramaUsuarioWhereUniqueInput;
    create: DiagramaUsuarioCreateInput;
    update: DiagramaUsuarioUpdateInput;
  }) => DiagramaUsuarioPromise;
  deleteDiagramaUsuario: (
    where: DiagramaUsuarioWhereUniqueInput
  ) => DiagramaUsuarioPromise;
  deleteManyDiagramaUsuarios: (
    where?: DiagramaUsuarioWhereInput
  ) => BatchPayloadPromise;
  createSala: (data: SalaCreateInput) => SalaPromise;
  updateSala: (args: {
    data: SalaUpdateInput;
    where: SalaWhereUniqueInput;
  }) => SalaPromise;
  updateManySalas: (args: {
    data: SalaUpdateManyMutationInput;
    where?: SalaWhereInput;
  }) => BatchPayloadPromise;
  upsertSala: (args: {
    where: SalaWhereUniqueInput;
    create: SalaCreateInput;
    update: SalaUpdateInput;
  }) => SalaPromise;
  deleteSala: (where: SalaWhereUniqueInput) => SalaPromise;
  deleteManySalas: (where?: SalaWhereInput) => BatchPayloadPromise;
  createUsuario: (data: UsuarioCreateInput) => UsuarioPromise;
  updateUsuario: (args: {
    data: UsuarioUpdateInput;
    where: UsuarioWhereUniqueInput;
  }) => UsuarioPromise;
  updateManyUsuarios: (args: {
    data: UsuarioUpdateManyMutationInput;
    where?: UsuarioWhereInput;
  }) => BatchPayloadPromise;
  upsertUsuario: (args: {
    where: UsuarioWhereUniqueInput;
    create: UsuarioCreateInput;
    update: UsuarioUpdateInput;
  }) => UsuarioPromise;
  deleteUsuario: (where: UsuarioWhereUniqueInput) => UsuarioPromise;
  deleteManyUsuarios: (where?: UsuarioWhereInput) => BatchPayloadPromise;
  createUsuarioSala: (data: UsuarioSalaCreateInput) => UsuarioSalaPromise;
  updateUsuarioSala: (args: {
    data: UsuarioSalaUpdateInput;
    where: UsuarioSalaWhereUniqueInput;
  }) => UsuarioSalaPromise;
  upsertUsuarioSala: (args: {
    where: UsuarioSalaWhereUniqueInput;
    create: UsuarioSalaCreateInput;
    update: UsuarioSalaUpdateInput;
  }) => UsuarioSalaPromise;
  deleteUsuarioSala: (where: UsuarioSalaWhereUniqueInput) => UsuarioSalaPromise;
  deleteManyUsuarioSalas: (
    where?: UsuarioSalaWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  diagrama: (
    where?: DiagramaSubscriptionWhereInput
  ) => DiagramaSubscriptionPayloadSubscription;
  diagramaUsuario: (
    where?: DiagramaUsuarioSubscriptionWhereInput
  ) => DiagramaUsuarioSubscriptionPayloadSubscription;
  sala: (
    where?: SalaSubscriptionWhereInput
  ) => SalaSubscriptionPayloadSubscription;
  usuario: (
    where?: UsuarioSubscriptionWhereInput
  ) => UsuarioSubscriptionPayloadSubscription;
  usuarioSala: (
    where?: UsuarioSalaSubscriptionWhereInput
  ) => UsuarioSalaSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DiagramaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "datos_ASC"
  | "datos_DESC";

export type UsuarioSalaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UsuarioOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "nombre_ASC"
  | "nombre_DESC"
  | "esAdmin_ASC"
  | "esAdmin_DESC";

export type SalaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "nombre_ASC"
  | "nombre_DESC";

export type DiagramaUsuarioOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface UsuarioUpsertWithWhereUniqueWithoutUsuarioSalaInput {
  where: UsuarioWhereUniqueInput;
  update: UsuarioUpdateWithoutUsuarioSalaDataInput;
  create: UsuarioCreateWithoutUsuarioSalaInput;
}

export type DiagramaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SalaUpdateManyWithoutUsuarioSalaInput {
  create?: Maybe<
    SalaCreateWithoutUsuarioSalaInput[] | SalaCreateWithoutUsuarioSalaInput
  >;
  delete?: Maybe<SalaWhereUniqueInput[] | SalaWhereUniqueInput>;
  connect?: Maybe<SalaWhereUniqueInput[] | SalaWhereUniqueInput>;
  set?: Maybe<SalaWhereUniqueInput[] | SalaWhereUniqueInput>;
  disconnect?: Maybe<SalaWhereUniqueInput[] | SalaWhereUniqueInput>;
  update?: Maybe<
    | SalaUpdateWithWhereUniqueWithoutUsuarioSalaInput[]
    | SalaUpdateWithWhereUniqueWithoutUsuarioSalaInput
  >;
  upsert?: Maybe<
    | SalaUpsertWithWhereUniqueWithoutUsuarioSalaInput[]
    | SalaUpsertWithWhereUniqueWithoutUsuarioSalaInput
  >;
  deleteMany?: Maybe<SalaScalarWhereInput[] | SalaScalarWhereInput>;
  updateMany?: Maybe<
    SalaUpdateManyWithWhereNestedInput[] | SalaUpdateManyWithWhereNestedInput
  >;
}

export interface UsuarioSalaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  usuarios_every?: Maybe<UsuarioWhereInput>;
  usuarios_some?: Maybe<UsuarioWhereInput>;
  usuarios_none?: Maybe<UsuarioWhereInput>;
  salas_every?: Maybe<SalaWhereInput>;
  salas_some?: Maybe<SalaWhereInput>;
  salas_none?: Maybe<SalaWhereInput>;
  AND?: Maybe<UsuarioSalaWhereInput[] | UsuarioSalaWhereInput>;
  OR?: Maybe<UsuarioSalaWhereInput[] | UsuarioSalaWhereInput>;
  NOT?: Maybe<UsuarioSalaWhereInput[] | UsuarioSalaWhereInput>;
}

export interface UsuarioCreateManyWithoutUsuarioSalaInput {
  create?: Maybe<
    | UsuarioCreateWithoutUsuarioSalaInput[]
    | UsuarioCreateWithoutUsuarioSalaInput
  >;
  connect?: Maybe<UsuarioWhereUniqueInput[] | UsuarioWhereUniqueInput>;
}

export interface DiagramaUpdateWithoutDiagramaUsuarioDataInput {
  datos?: Maybe<String>;
}

export interface UsuarioCreateWithoutUsuarioSalaInput {
  id?: Maybe<ID_Input>;
  nombre: String;
  esAdmin?: Maybe<Boolean>;
}

export interface SalaUpdateWithWhereUniqueWithoutUsuarioSalaInput {
  where: SalaWhereUniqueInput;
  data: SalaUpdateWithoutUsuarioSalaDataInput;
}

export interface SalaCreateManyWithoutUsuarioSalaInput {
  create?: Maybe<
    SalaCreateWithoutUsuarioSalaInput[] | SalaCreateWithoutUsuarioSalaInput
  >;
  connect?: Maybe<SalaWhereUniqueInput[] | SalaWhereUniqueInput>;
}

export interface UsuarioSalaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UsuarioSalaWhereInput>;
  AND?: Maybe<
    UsuarioSalaSubscriptionWhereInput[] | UsuarioSalaSubscriptionWhereInput
  >;
  OR?: Maybe<
    UsuarioSalaSubscriptionWhereInput[] | UsuarioSalaSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UsuarioSalaSubscriptionWhereInput[] | UsuarioSalaSubscriptionWhereInput
  >;
}

export interface SalaCreateWithoutUsuarioSalaInput {
  id?: Maybe<ID_Input>;
  nombre: String;
}

export interface UsuarioSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UsuarioWhereInput>;
  AND?: Maybe<UsuarioSubscriptionWhereInput[] | UsuarioSubscriptionWhereInput>;
  OR?: Maybe<UsuarioSubscriptionWhereInput[] | UsuarioSubscriptionWhereInput>;
  NOT?: Maybe<UsuarioSubscriptionWhereInput[] | UsuarioSubscriptionWhereInput>;
}

export interface DiagramaUpdateInput {
  datos?: Maybe<String>;
  diagramaUsuario?: Maybe<DiagramaUsuarioUpdateOneWithoutDiagramasInput>;
}

export interface DiagramaUsuarioSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DiagramaUsuarioWhereInput>;
  AND?: Maybe<
    | DiagramaUsuarioSubscriptionWhereInput[]
    | DiagramaUsuarioSubscriptionWhereInput
  >;
  OR?: Maybe<
    | DiagramaUsuarioSubscriptionWhereInput[]
    | DiagramaUsuarioSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | DiagramaUsuarioSubscriptionWhereInput[]
    | DiagramaUsuarioSubscriptionWhereInput
  >;
}

export interface DiagramaUsuarioUpdateOneWithoutDiagramasInput {
  create?: Maybe<DiagramaUsuarioCreateWithoutDiagramasInput>;
  update?: Maybe<DiagramaUsuarioUpdateWithoutDiagramasDataInput>;
  upsert?: Maybe<DiagramaUsuarioUpsertWithoutDiagramasInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DiagramaUsuarioWhereUniqueInput>;
}

export interface UsuarioSalaUpdateInput {
  usuarios?: Maybe<UsuarioUpdateManyWithoutUsuarioSalaInput>;
  salas?: Maybe<SalaUpdateManyWithoutUsuarioSalaInput>;
}

export interface DiagramaUsuarioUpdateWithoutDiagramasDataInput {
  usuariosSala?: Maybe<UsuarioSalaUpdateManyInput>;
}

export interface UsuarioSalaUpsertWithoutUsuariosInput {
  update: UsuarioSalaUpdateWithoutUsuariosDataInput;
  create: UsuarioSalaCreateWithoutUsuariosInput;
}

export interface UsuarioSalaUpdateManyInput {
  create?: Maybe<UsuarioSalaCreateInput[] | UsuarioSalaCreateInput>;
  update?: Maybe<
    | UsuarioSalaUpdateWithWhereUniqueNestedInput[]
    | UsuarioSalaUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UsuarioSalaUpsertWithWhereUniqueNestedInput[]
    | UsuarioSalaUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UsuarioSalaWhereUniqueInput[] | UsuarioSalaWhereUniqueInput>;
  connect?: Maybe<UsuarioSalaWhereUniqueInput[] | UsuarioSalaWhereUniqueInput>;
  set?: Maybe<UsuarioSalaWhereUniqueInput[] | UsuarioSalaWhereUniqueInput>;
  disconnect?: Maybe<
    UsuarioSalaWhereUniqueInput[] | UsuarioSalaWhereUniqueInput
  >;
  deleteMany?: Maybe<
    UsuarioSalaScalarWhereInput[] | UsuarioSalaScalarWhereInput
  >;
}

export interface UsuarioSalaUpdateOneWithoutUsuariosInput {
  create?: Maybe<UsuarioSalaCreateWithoutUsuariosInput>;
  update?: Maybe<UsuarioSalaUpdateWithoutUsuariosDataInput>;
  upsert?: Maybe<UsuarioSalaUpsertWithoutUsuariosInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UsuarioSalaWhereUniqueInput>;
}

export interface UsuarioSalaUpdateWithWhereUniqueNestedInput {
  where: UsuarioSalaWhereUniqueInput;
  data: UsuarioSalaUpdateDataInput;
}

export interface UsuarioUpdateInput {
  nombre?: Maybe<String>;
  esAdmin?: Maybe<Boolean>;
  usuarioSala?: Maybe<UsuarioSalaUpdateOneWithoutUsuariosInput>;
}

export interface UsuarioSalaUpdateDataInput {
  usuarios?: Maybe<UsuarioUpdateManyWithoutUsuarioSalaInput>;
  salas?: Maybe<SalaUpdateManyWithoutUsuarioSalaInput>;
}

export interface UsuarioSalaCreateOneWithoutUsuariosInput {
  create?: Maybe<UsuarioSalaCreateWithoutUsuariosInput>;
  connect?: Maybe<UsuarioSalaWhereUniqueInput>;
}

export interface UsuarioUpdateManyWithoutUsuarioSalaInput {
  create?: Maybe<
    | UsuarioCreateWithoutUsuarioSalaInput[]
    | UsuarioCreateWithoutUsuarioSalaInput
  >;
  delete?: Maybe<UsuarioWhereUniqueInput[] | UsuarioWhereUniqueInput>;
  connect?: Maybe<UsuarioWhereUniqueInput[] | UsuarioWhereUniqueInput>;
  set?: Maybe<UsuarioWhereUniqueInput[] | UsuarioWhereUniqueInput>;
  disconnect?: Maybe<UsuarioWhereUniqueInput[] | UsuarioWhereUniqueInput>;
  update?: Maybe<
    | UsuarioUpdateWithWhereUniqueWithoutUsuarioSalaInput[]
    | UsuarioUpdateWithWhereUniqueWithoutUsuarioSalaInput
  >;
  upsert?: Maybe<
    | UsuarioUpsertWithWhereUniqueWithoutUsuarioSalaInput[]
    | UsuarioUpsertWithWhereUniqueWithoutUsuarioSalaInput
  >;
  deleteMany?: Maybe<UsuarioScalarWhereInput[] | UsuarioScalarWhereInput>;
  updateMany?: Maybe<
    | UsuarioUpdateManyWithWhereNestedInput[]
    | UsuarioUpdateManyWithWhereNestedInput
  >;
}

export type SalaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UsuarioUpdateWithWhereUniqueWithoutUsuarioSalaInput {
  where: UsuarioWhereUniqueInput;
  data: UsuarioUpdateWithoutUsuarioSalaDataInput;
}

export interface UsuarioSalaUpsertWithoutSalasInput {
  update: UsuarioSalaUpdateWithoutSalasDataInput;
  create: UsuarioSalaCreateWithoutSalasInput;
}

export interface UsuarioUpdateWithoutUsuarioSalaDataInput {
  nombre?: Maybe<String>;
  esAdmin?: Maybe<Boolean>;
}

export type UsuarioWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DiagramaUpdateManyWithWhereNestedInput {
  where: DiagramaScalarWhereInput;
  data: DiagramaUpdateManyDataInput;
}

export interface SalaUpdateInput {
  nombre?: Maybe<String>;
  usuarioSala?: Maybe<UsuarioSalaUpdateOneWithoutSalasInput>;
}

export interface UsuarioScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  nombre?: Maybe<String>;
  nombre_not?: Maybe<String>;
  nombre_in?: Maybe<String[] | String>;
  nombre_not_in?: Maybe<String[] | String>;
  nombre_lt?: Maybe<String>;
  nombre_lte?: Maybe<String>;
  nombre_gt?: Maybe<String>;
  nombre_gte?: Maybe<String>;
  nombre_contains?: Maybe<String>;
  nombre_not_contains?: Maybe<String>;
  nombre_starts_with?: Maybe<String>;
  nombre_not_starts_with?: Maybe<String>;
  nombre_ends_with?: Maybe<String>;
  nombre_not_ends_with?: Maybe<String>;
  esAdmin?: Maybe<Boolean>;
  esAdmin_not?: Maybe<Boolean>;
  AND?: Maybe<UsuarioScalarWhereInput[] | UsuarioScalarWhereInput>;
  OR?: Maybe<UsuarioScalarWhereInput[] | UsuarioScalarWhereInput>;
  NOT?: Maybe<UsuarioScalarWhereInput[] | UsuarioScalarWhereInput>;
}

export type UsuarioSalaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UsuarioUpdateManyWithWhereNestedInput {
  where: UsuarioScalarWhereInput;
  data: UsuarioUpdateManyDataInput;
}

export interface SalaCreateInput {
  id?: Maybe<ID_Input>;
  nombre: String;
  usuarioSala?: Maybe<UsuarioSalaCreateOneWithoutSalasInput>;
}

export interface UsuarioUpdateManyDataInput {
  nombre?: Maybe<String>;
  esAdmin?: Maybe<Boolean>;
}

export interface DiagramaUsuarioCreateOneWithoutDiagramasInput {
  create?: Maybe<DiagramaUsuarioCreateWithoutDiagramasInput>;
  connect?: Maybe<DiagramaUsuarioWhereUniqueInput>;
}

export interface UsuarioWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  nombre?: Maybe<String>;
  nombre_not?: Maybe<String>;
  nombre_in?: Maybe<String[] | String>;
  nombre_not_in?: Maybe<String[] | String>;
  nombre_lt?: Maybe<String>;
  nombre_lte?: Maybe<String>;
  nombre_gt?: Maybe<String>;
  nombre_gte?: Maybe<String>;
  nombre_contains?: Maybe<String>;
  nombre_not_contains?: Maybe<String>;
  nombre_starts_with?: Maybe<String>;
  nombre_not_starts_with?: Maybe<String>;
  nombre_ends_with?: Maybe<String>;
  nombre_not_ends_with?: Maybe<String>;
  esAdmin?: Maybe<Boolean>;
  esAdmin_not?: Maybe<Boolean>;
  usuarioSala?: Maybe<UsuarioSalaWhereInput>;
  AND?: Maybe<UsuarioWhereInput[] | UsuarioWhereInput>;
  OR?: Maybe<UsuarioWhereInput[] | UsuarioWhereInput>;
  NOT?: Maybe<UsuarioWhereInput[] | UsuarioWhereInput>;
}

export interface UsuarioSalaCreateManyInput {
  create?: Maybe<UsuarioSalaCreateInput[] | UsuarioSalaCreateInput>;
  connect?: Maybe<UsuarioSalaWhereUniqueInput[] | UsuarioSalaWhereUniqueInput>;
}

export interface SalaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  nombre?: Maybe<String>;
  nombre_not?: Maybe<String>;
  nombre_in?: Maybe<String[] | String>;
  nombre_not_in?: Maybe<String[] | String>;
  nombre_lt?: Maybe<String>;
  nombre_lte?: Maybe<String>;
  nombre_gt?: Maybe<String>;
  nombre_gte?: Maybe<String>;
  nombre_contains?: Maybe<String>;
  nombre_not_contains?: Maybe<String>;
  nombre_starts_with?: Maybe<String>;
  nombre_not_starts_with?: Maybe<String>;
  nombre_ends_with?: Maybe<String>;
  nombre_not_ends_with?: Maybe<String>;
  usuarioSala?: Maybe<UsuarioSalaWhereInput>;
  AND?: Maybe<SalaWhereInput[] | SalaWhereInput>;
  OR?: Maybe<SalaWhereInput[] | SalaWhereInput>;
  NOT?: Maybe<SalaWhereInput[] | SalaWhereInput>;
}

export interface DiagramaUsuarioWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  diagramas_every?: Maybe<DiagramaWhereInput>;
  diagramas_some?: Maybe<DiagramaWhereInput>;
  diagramas_none?: Maybe<DiagramaWhereInput>;
  usuariosSala_every?: Maybe<UsuarioSalaWhereInput>;
  usuariosSala_some?: Maybe<UsuarioSalaWhereInput>;
  usuariosSala_none?: Maybe<UsuarioSalaWhereInput>;
  AND?: Maybe<DiagramaUsuarioWhereInput[] | DiagramaUsuarioWhereInput>;
  OR?: Maybe<DiagramaUsuarioWhereInput[] | DiagramaUsuarioWhereInput>;
  NOT?: Maybe<DiagramaUsuarioWhereInput[] | DiagramaUsuarioWhereInput>;
}

export interface SalaUpdateWithoutUsuarioSalaDataInput {
  nombre?: Maybe<String>;
}

export interface SalaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SalaWhereInput>;
  AND?: Maybe<SalaSubscriptionWhereInput[] | SalaSubscriptionWhereInput>;
  OR?: Maybe<SalaSubscriptionWhereInput[] | SalaSubscriptionWhereInput>;
  NOT?: Maybe<SalaSubscriptionWhereInput[] | SalaSubscriptionWhereInput>;
}

export interface SalaUpsertWithWhereUniqueWithoutUsuarioSalaInput {
  where: SalaWhereUniqueInput;
  update: SalaUpdateWithoutUsuarioSalaDataInput;
  create: SalaCreateWithoutUsuarioSalaInput;
}

export interface UsuarioUpdateManyMutationInput {
  nombre?: Maybe<String>;
  esAdmin?: Maybe<Boolean>;
}

export interface SalaScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  nombre?: Maybe<String>;
  nombre_not?: Maybe<String>;
  nombre_in?: Maybe<String[] | String>;
  nombre_not_in?: Maybe<String[] | String>;
  nombre_lt?: Maybe<String>;
  nombre_lte?: Maybe<String>;
  nombre_gt?: Maybe<String>;
  nombre_gte?: Maybe<String>;
  nombre_contains?: Maybe<String>;
  nombre_not_contains?: Maybe<String>;
  nombre_starts_with?: Maybe<String>;
  nombre_not_starts_with?: Maybe<String>;
  nombre_ends_with?: Maybe<String>;
  nombre_not_ends_with?: Maybe<String>;
  AND?: Maybe<SalaScalarWhereInput[] | SalaScalarWhereInput>;
  OR?: Maybe<SalaScalarWhereInput[] | SalaScalarWhereInput>;
  NOT?: Maybe<SalaScalarWhereInput[] | SalaScalarWhereInput>;
}

export type DiagramaUsuarioWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SalaUpdateManyWithWhereNestedInput {
  where: SalaScalarWhereInput;
  data: SalaUpdateManyDataInput;
}

export interface UsuarioCreateInput {
  id?: Maybe<ID_Input>;
  nombre: String;
  esAdmin?: Maybe<Boolean>;
  usuarioSala?: Maybe<UsuarioSalaCreateOneWithoutUsuariosInput>;
}

export interface SalaUpdateManyDataInput {
  nombre?: Maybe<String>;
}

export interface UsuarioSalaUpdateWithoutSalasDataInput {
  usuarios?: Maybe<UsuarioUpdateManyWithoutUsuarioSalaInput>;
}

export interface UsuarioSalaUpsertWithWhereUniqueNestedInput {
  where: UsuarioSalaWhereUniqueInput;
  update: UsuarioSalaUpdateDataInput;
  create: UsuarioSalaCreateInput;
}

export interface UsuarioSalaCreateWithoutSalasInput {
  id?: Maybe<ID_Input>;
  usuarios?: Maybe<UsuarioCreateManyWithoutUsuarioSalaInput>;
}

export interface UsuarioSalaScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UsuarioSalaScalarWhereInput[] | UsuarioSalaScalarWhereInput>;
  OR?: Maybe<UsuarioSalaScalarWhereInput[] | UsuarioSalaScalarWhereInput>;
  NOT?: Maybe<UsuarioSalaScalarWhereInput[] | UsuarioSalaScalarWhereInput>;
}

export interface DiagramaUpdateManyDataInput {
  datos?: Maybe<String>;
}

export interface DiagramaUsuarioUpsertWithoutDiagramasInput {
  update: DiagramaUsuarioUpdateWithoutDiagramasDataInput;
  create: DiagramaUsuarioCreateWithoutDiagramasInput;
}

export interface DiagramaUsuarioCreateWithoutDiagramasInput {
  id?: Maybe<ID_Input>;
  usuariosSala?: Maybe<UsuarioSalaCreateManyInput>;
}

export interface DiagramaUpdateManyMutationInput {
  datos?: Maybe<String>;
}

export interface DiagramaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  datos?: Maybe<String>;
  datos_not?: Maybe<String>;
  datos_in?: Maybe<String[] | String>;
  datos_not_in?: Maybe<String[] | String>;
  datos_lt?: Maybe<String>;
  datos_lte?: Maybe<String>;
  datos_gt?: Maybe<String>;
  datos_gte?: Maybe<String>;
  datos_contains?: Maybe<String>;
  datos_not_contains?: Maybe<String>;
  datos_starts_with?: Maybe<String>;
  datos_not_starts_with?: Maybe<String>;
  datos_ends_with?: Maybe<String>;
  datos_not_ends_with?: Maybe<String>;
  diagramaUsuario?: Maybe<DiagramaUsuarioWhereInput>;
  AND?: Maybe<DiagramaWhereInput[] | DiagramaWhereInput>;
  OR?: Maybe<DiagramaWhereInput[] | DiagramaWhereInput>;
  NOT?: Maybe<DiagramaWhereInput[] | DiagramaWhereInput>;
}

export interface DiagramaScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  datos?: Maybe<String>;
  datos_not?: Maybe<String>;
  datos_in?: Maybe<String[] | String>;
  datos_not_in?: Maybe<String[] | String>;
  datos_lt?: Maybe<String>;
  datos_lte?: Maybe<String>;
  datos_gt?: Maybe<String>;
  datos_gte?: Maybe<String>;
  datos_contains?: Maybe<String>;
  datos_not_contains?: Maybe<String>;
  datos_starts_with?: Maybe<String>;
  datos_not_starts_with?: Maybe<String>;
  datos_ends_with?: Maybe<String>;
  datos_not_ends_with?: Maybe<String>;
  AND?: Maybe<DiagramaScalarWhereInput[] | DiagramaScalarWhereInput>;
  OR?: Maybe<DiagramaScalarWhereInput[] | DiagramaScalarWhereInput>;
  NOT?: Maybe<DiagramaScalarWhereInput[] | DiagramaScalarWhereInput>;
}

export interface UsuarioSalaUpdateWithoutUsuariosDataInput {
  salas?: Maybe<SalaUpdateManyWithoutUsuarioSalaInput>;
}

export interface DiagramaUpsertWithWhereUniqueWithoutDiagramaUsuarioInput {
  where: DiagramaWhereUniqueInput;
  update: DiagramaUpdateWithoutDiagramaUsuarioDataInput;
  create: DiagramaCreateWithoutDiagramaUsuarioInput;
}

export interface SalaUpdateManyMutationInput {
  nombre?: Maybe<String>;
}

export interface DiagramaUsuarioCreateInput {
  id?: Maybe<ID_Input>;
  diagramas?: Maybe<DiagramaCreateManyWithoutDiagramaUsuarioInput>;
  usuariosSala?: Maybe<UsuarioSalaCreateManyInput>;
}

export interface UsuarioSalaCreateOneWithoutSalasInput {
  create?: Maybe<UsuarioSalaCreateWithoutSalasInput>;
  connect?: Maybe<UsuarioSalaWhereUniqueInput>;
}

export interface DiagramaCreateManyWithoutDiagramaUsuarioInput {
  create?: Maybe<
    | DiagramaCreateWithoutDiagramaUsuarioInput[]
    | DiagramaCreateWithoutDiagramaUsuarioInput
  >;
  connect?: Maybe<DiagramaWhereUniqueInput[] | DiagramaWhereUniqueInput>;
}

export interface UsuarioSalaCreateInput {
  id?: Maybe<ID_Input>;
  usuarios?: Maybe<UsuarioCreateManyWithoutUsuarioSalaInput>;
  salas?: Maybe<SalaCreateManyWithoutUsuarioSalaInput>;
}

export interface DiagramaUpdateWithWhereUniqueWithoutDiagramaUsuarioInput {
  where: DiagramaWhereUniqueInput;
  data: DiagramaUpdateWithoutDiagramaUsuarioDataInput;
}

export interface DiagramaUpdateManyWithoutDiagramaUsuarioInput {
  create?: Maybe<
    | DiagramaCreateWithoutDiagramaUsuarioInput[]
    | DiagramaCreateWithoutDiagramaUsuarioInput
  >;
  delete?: Maybe<DiagramaWhereUniqueInput[] | DiagramaWhereUniqueInput>;
  connect?: Maybe<DiagramaWhereUniqueInput[] | DiagramaWhereUniqueInput>;
  set?: Maybe<DiagramaWhereUniqueInput[] | DiagramaWhereUniqueInput>;
  disconnect?: Maybe<DiagramaWhereUniqueInput[] | DiagramaWhereUniqueInput>;
  update?: Maybe<
    | DiagramaUpdateWithWhereUniqueWithoutDiagramaUsuarioInput[]
    | DiagramaUpdateWithWhereUniqueWithoutDiagramaUsuarioInput
  >;
  upsert?: Maybe<
    | DiagramaUpsertWithWhereUniqueWithoutDiagramaUsuarioInput[]
    | DiagramaUpsertWithWhereUniqueWithoutDiagramaUsuarioInput
  >;
  deleteMany?: Maybe<DiagramaScalarWhereInput[] | DiagramaScalarWhereInput>;
  updateMany?: Maybe<
    | DiagramaUpdateManyWithWhereNestedInput[]
    | DiagramaUpdateManyWithWhereNestedInput
  >;
}

export interface DiagramaUsuarioUpdateInput {
  diagramas?: Maybe<DiagramaUpdateManyWithoutDiagramaUsuarioInput>;
  usuariosSala?: Maybe<UsuarioSalaUpdateManyInput>;
}

export interface DiagramaCreateWithoutDiagramaUsuarioInput {
  id?: Maybe<ID_Input>;
  datos: String;
}

export interface DiagramaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DiagramaWhereInput>;
  AND?: Maybe<
    DiagramaSubscriptionWhereInput[] | DiagramaSubscriptionWhereInput
  >;
  OR?: Maybe<DiagramaSubscriptionWhereInput[] | DiagramaSubscriptionWhereInput>;
  NOT?: Maybe<
    DiagramaSubscriptionWhereInput[] | DiagramaSubscriptionWhereInput
  >;
}

export interface DiagramaCreateInput {
  id?: Maybe<ID_Input>;
  datos: String;
  diagramaUsuario?: Maybe<DiagramaUsuarioCreateOneWithoutDiagramasInput>;
}

export interface UsuarioSalaUpdateOneWithoutSalasInput {
  create?: Maybe<UsuarioSalaCreateWithoutSalasInput>;
  update?: Maybe<UsuarioSalaUpdateWithoutSalasDataInput>;
  upsert?: Maybe<UsuarioSalaUpsertWithoutSalasInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UsuarioSalaWhereUniqueInput>;
}

export interface UsuarioSalaCreateWithoutUsuariosInput {
  id?: Maybe<ID_Input>;
  salas?: Maybe<SalaCreateManyWithoutUsuarioSalaInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UsuarioSalaPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UsuarioSalaPreviousValuesPromise
  extends Promise<UsuarioSalaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UsuarioSalaPreviousValuesSubscription
  extends Promise<AsyncIterator<UsuarioSalaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateDiagrama {
  count: Int;
}

export interface AggregateDiagramaPromise
  extends Promise<AggregateDiagrama>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiagramaSubscription
  extends Promise<AsyncIterator<AggregateDiagrama>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UsuarioSala {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UsuarioSalaPromise extends Promise<UsuarioSala>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  usuarios: <T = FragmentableArray<Usuario>>(args?: {
    where?: UsuarioWhereInput;
    orderBy?: UsuarioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  salas: <T = FragmentableArray<Sala>>(args?: {
    where?: SalaWhereInput;
    orderBy?: SalaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UsuarioSalaSubscription
  extends Promise<AsyncIterator<UsuarioSala>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  usuarios: <T = Promise<AsyncIterator<UsuarioSubscription>>>(args?: {
    where?: UsuarioWhereInput;
    orderBy?: UsuarioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  salas: <T = Promise<AsyncIterator<SalaSubscription>>>(args?: {
    where?: SalaWhereInput;
    orderBy?: SalaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UsuarioSalaNullablePromise
  extends Promise<UsuarioSala | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  usuarios: <T = FragmentableArray<Usuario>>(args?: {
    where?: UsuarioWhereInput;
    orderBy?: UsuarioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  salas: <T = FragmentableArray<Sala>>(args?: {
    where?: SalaWhereInput;
    orderBy?: SalaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DiagramaEdge {
  node: Diagrama;
  cursor: String;
}

export interface DiagramaEdgePromise
  extends Promise<DiagramaEdge>,
    Fragmentable {
  node: <T = DiagramaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiagramaEdgeSubscription
  extends Promise<AsyncIterator<DiagramaEdge>>,
    Fragmentable {
  node: <T = DiagramaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateUsuarioSala {
  count: Int;
}

export interface AggregateUsuarioSalaPromise
  extends Promise<AggregateUsuarioSala>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUsuarioSalaSubscription
  extends Promise<AsyncIterator<AggregateUsuarioSala>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DiagramaConnection {
  pageInfo: PageInfo;
  edges: DiagramaEdge[];
}

export interface DiagramaConnectionPromise
  extends Promise<DiagramaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiagramaEdge>>() => T;
  aggregate: <T = AggregateDiagramaPromise>() => T;
}

export interface DiagramaConnectionSubscription
  extends Promise<AsyncIterator<DiagramaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiagramaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiagramaSubscription>() => T;
}

export interface UsuarioSalaConnection {
  pageInfo: PageInfo;
  edges: UsuarioSalaEdge[];
}

export interface UsuarioSalaConnectionPromise
  extends Promise<UsuarioSalaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UsuarioSalaEdge>>() => T;
  aggregate: <T = AggregateUsuarioSalaPromise>() => T;
}

export interface UsuarioSalaConnectionSubscription
  extends Promise<AsyncIterator<UsuarioSalaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UsuarioSalaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUsuarioSalaSubscription>() => T;
}

export interface Sala {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  nombre: String;
}

export interface SalaPromise extends Promise<Sala>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nombre: () => Promise<String>;
  usuarioSala: <T = UsuarioSalaPromise>() => T;
}

export interface SalaSubscription
  extends Promise<AsyncIterator<Sala>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  nombre: () => Promise<AsyncIterator<String>>;
  usuarioSala: <T = UsuarioSalaSubscription>() => T;
}

export interface SalaNullablePromise
  extends Promise<Sala | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nombre: () => Promise<String>;
  usuarioSala: <T = UsuarioSalaPromise>() => T;
}

export interface UsuarioEdge {
  node: Usuario;
  cursor: String;
}

export interface UsuarioEdgePromise extends Promise<UsuarioEdge>, Fragmentable {
  node: <T = UsuarioPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UsuarioEdgeSubscription
  extends Promise<AsyncIterator<UsuarioEdge>>,
    Fragmentable {
  node: <T = UsuarioSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UsuarioSubscriptionPayload {
  mutation: MutationType;
  node: Usuario;
  updatedFields: String[];
  previousValues: UsuarioPreviousValues;
}

export interface UsuarioSubscriptionPayloadPromise
  extends Promise<UsuarioSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UsuarioPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UsuarioPreviousValuesPromise>() => T;
}

export interface UsuarioSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UsuarioSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UsuarioSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UsuarioPreviousValuesSubscription>() => T;
}

export interface AggregateSala {
  count: Int;
}

export interface AggregateSalaPromise
  extends Promise<AggregateSala>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSalaSubscription
  extends Promise<AsyncIterator<AggregateSala>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Diagrama {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  datos: String;
}

export interface DiagramaPromise extends Promise<Diagrama>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  datos: () => Promise<String>;
  diagramaUsuario: <T = DiagramaUsuarioPromise>() => T;
}

export interface DiagramaSubscription
  extends Promise<AsyncIterator<Diagrama>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  datos: () => Promise<AsyncIterator<String>>;
  diagramaUsuario: <T = DiagramaUsuarioSubscription>() => T;
}

export interface DiagramaNullablePromise
  extends Promise<Diagrama | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  datos: () => Promise<String>;
  diagramaUsuario: <T = DiagramaUsuarioPromise>() => T;
}

export interface SalaConnection {
  pageInfo: PageInfo;
  edges: SalaEdge[];
}

export interface SalaConnectionPromise
  extends Promise<SalaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SalaEdge>>() => T;
  aggregate: <T = AggregateSalaPromise>() => T;
}

export interface SalaConnectionSubscription
  extends Promise<AsyncIterator<SalaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SalaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSalaSubscription>() => T;
}

export interface DiagramaSubscriptionPayload {
  mutation: MutationType;
  node: Diagrama;
  updatedFields: String[];
  previousValues: DiagramaPreviousValues;
}

export interface DiagramaSubscriptionPayloadPromise
  extends Promise<DiagramaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiagramaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiagramaPreviousValuesPromise>() => T;
}

export interface DiagramaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiagramaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiagramaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiagramaPreviousValuesSubscription>() => T;
}

export interface DiagramaUsuarioEdge {
  node: DiagramaUsuario;
  cursor: String;
}

export interface DiagramaUsuarioEdgePromise
  extends Promise<DiagramaUsuarioEdge>,
    Fragmentable {
  node: <T = DiagramaUsuarioPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiagramaUsuarioEdgeSubscription
  extends Promise<AsyncIterator<DiagramaUsuarioEdge>>,
    Fragmentable {
  node: <T = DiagramaUsuarioSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DiagramaPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  datos: String;
}

export interface DiagramaPreviousValuesPromise
  extends Promise<DiagramaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  datos: () => Promise<String>;
}

export interface DiagramaPreviousValuesSubscription
  extends Promise<AsyncIterator<DiagramaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  datos: () => Promise<AsyncIterator<String>>;
}

export interface UsuarioPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  nombre: String;
  esAdmin: Boolean;
}

export interface UsuarioPreviousValuesPromise
  extends Promise<UsuarioPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nombre: () => Promise<String>;
  esAdmin: () => Promise<Boolean>;
}

export interface UsuarioPreviousValuesSubscription
  extends Promise<AsyncIterator<UsuarioPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  nombre: () => Promise<AsyncIterator<String>>;
  esAdmin: () => Promise<AsyncIterator<Boolean>>;
}

export interface Usuario {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  nombre: String;
  esAdmin: Boolean;
}

export interface UsuarioPromise extends Promise<Usuario>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nombre: () => Promise<String>;
  esAdmin: () => Promise<Boolean>;
  usuarioSala: <T = UsuarioSalaPromise>() => T;
}

export interface UsuarioSubscription
  extends Promise<AsyncIterator<Usuario>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  nombre: () => Promise<AsyncIterator<String>>;
  esAdmin: () => Promise<AsyncIterator<Boolean>>;
  usuarioSala: <T = UsuarioSalaSubscription>() => T;
}

export interface UsuarioNullablePromise
  extends Promise<Usuario | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nombre: () => Promise<String>;
  esAdmin: () => Promise<Boolean>;
  usuarioSala: <T = UsuarioSalaPromise>() => T;
}

export interface UsuarioSalaEdge {
  node: UsuarioSala;
  cursor: String;
}

export interface UsuarioSalaEdgePromise
  extends Promise<UsuarioSalaEdge>,
    Fragmentable {
  node: <T = UsuarioSalaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UsuarioSalaEdgeSubscription
  extends Promise<AsyncIterator<UsuarioSalaEdge>>,
    Fragmentable {
  node: <T = UsuarioSalaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DiagramaUsuarioSubscriptionPayload {
  mutation: MutationType;
  node: DiagramaUsuario;
  updatedFields: String[];
  previousValues: DiagramaUsuarioPreviousValues;
}

export interface DiagramaUsuarioSubscriptionPayloadPromise
  extends Promise<DiagramaUsuarioSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiagramaUsuarioPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiagramaUsuarioPreviousValuesPromise>() => T;
}

export interface DiagramaUsuarioSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiagramaUsuarioSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiagramaUsuarioSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiagramaUsuarioPreviousValuesSubscription>() => T;
}

export interface UsuarioConnection {
  pageInfo: PageInfo;
  edges: UsuarioEdge[];
}

export interface UsuarioConnectionPromise
  extends Promise<UsuarioConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UsuarioEdge>>() => T;
  aggregate: <T = AggregateUsuarioPromise>() => T;
}

export interface UsuarioConnectionSubscription
  extends Promise<AsyncIterator<UsuarioConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UsuarioEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUsuarioSubscription>() => T;
}

export interface AggregateDiagramaUsuario {
  count: Int;
}

export interface AggregateDiagramaUsuarioPromise
  extends Promise<AggregateDiagramaUsuario>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiagramaUsuarioSubscription
  extends Promise<AsyncIterator<AggregateDiagramaUsuario>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SalaPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  nombre: String;
}

export interface SalaPreviousValuesPromise
  extends Promise<SalaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nombre: () => Promise<String>;
}

export interface SalaPreviousValuesSubscription
  extends Promise<AsyncIterator<SalaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  nombre: () => Promise<AsyncIterator<String>>;
}

export interface SalaSubscriptionPayload {
  mutation: MutationType;
  node: Sala;
  updatedFields: String[];
  previousValues: SalaPreviousValues;
}

export interface SalaSubscriptionPayloadPromise
  extends Promise<SalaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SalaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SalaPreviousValuesPromise>() => T;
}

export interface SalaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SalaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SalaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SalaPreviousValuesSubscription>() => T;
}

export interface DiagramaUsuario {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DiagramaUsuarioPromise
  extends Promise<DiagramaUsuario>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  diagramas: <T = FragmentableArray<Diagrama>>(args?: {
    where?: DiagramaWhereInput;
    orderBy?: DiagramaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  usuariosSala: <T = FragmentableArray<UsuarioSala>>(args?: {
    where?: UsuarioSalaWhereInput;
    orderBy?: UsuarioSalaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DiagramaUsuarioSubscription
  extends Promise<AsyncIterator<DiagramaUsuario>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  diagramas: <T = Promise<AsyncIterator<DiagramaSubscription>>>(args?: {
    where?: DiagramaWhereInput;
    orderBy?: DiagramaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  usuariosSala: <T = Promise<AsyncIterator<UsuarioSalaSubscription>>>(args?: {
    where?: UsuarioSalaWhereInput;
    orderBy?: UsuarioSalaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DiagramaUsuarioNullablePromise
  extends Promise<DiagramaUsuario | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  diagramas: <T = FragmentableArray<Diagrama>>(args?: {
    where?: DiagramaWhereInput;
    orderBy?: DiagramaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  usuariosSala: <T = FragmentableArray<UsuarioSala>>(args?: {
    where?: UsuarioSalaWhereInput;
    orderBy?: UsuarioSalaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DiagramaUsuarioPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DiagramaUsuarioPreviousValuesPromise
  extends Promise<DiagramaUsuarioPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DiagramaUsuarioPreviousValuesSubscription
  extends Promise<AsyncIterator<DiagramaUsuarioPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DiagramaUsuarioConnection {
  pageInfo: PageInfo;
  edges: DiagramaUsuarioEdge[];
}

export interface DiagramaUsuarioConnectionPromise
  extends Promise<DiagramaUsuarioConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiagramaUsuarioEdge>>() => T;
  aggregate: <T = AggregateDiagramaUsuarioPromise>() => T;
}

export interface DiagramaUsuarioConnectionSubscription
  extends Promise<AsyncIterator<DiagramaUsuarioConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiagramaUsuarioEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiagramaUsuarioSubscription>() => T;
}

export interface SalaEdge {
  node: Sala;
  cursor: String;
}

export interface SalaEdgePromise extends Promise<SalaEdge>, Fragmentable {
  node: <T = SalaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SalaEdgeSubscription
  extends Promise<AsyncIterator<SalaEdge>>,
    Fragmentable {
  node: <T = SalaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUsuario {
  count: Int;
}

export interface AggregateUsuarioPromise
  extends Promise<AggregateUsuario>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUsuarioSubscription
  extends Promise<AsyncIterator<AggregateUsuario>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UsuarioSalaSubscriptionPayload {
  mutation: MutationType;
  node: UsuarioSala;
  updatedFields: String[];
  previousValues: UsuarioSalaPreviousValues;
}

export interface UsuarioSalaSubscriptionPayloadPromise
  extends Promise<UsuarioSalaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UsuarioSalaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UsuarioSalaPreviousValuesPromise>() => T;
}

export interface UsuarioSalaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UsuarioSalaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UsuarioSalaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UsuarioSalaPreviousValuesSubscription>() => T;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "UsuarioSala",
    embedded: false
  },
  {
    name: "Sala",
    embedded: false
  },
  {
    name: "Usuario",
    embedded: false
  },
  {
    name: "Diagrama",
    embedded: false
  },
  {
    name: "DiagramaUsuario",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://sala-reunion-c09c320c32.herokuapp.com/sala-reunion-puzzle/dev`
});
export const prisma = new Prisma();
